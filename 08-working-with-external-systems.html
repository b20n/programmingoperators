<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Working with External Systems</title>
<meta name="generator" content="Org mode">
</head>
<body>
<div id="content">
<h1 class="title">Working with External Systems</h1>
<p>
One of the challenges of managing complex stateful systems is that
they tend to be hard to "contain": their correct behavior depends on a
range of technologies such as:
</p>

<ul class="org-ul">
<li>distributed consensus stores (etcd, chubby)</li>
<li>block storage volumes</li>
<li>object storage buckets</li>
</ul>

<p>
These systems probably aren't running on top of Kubernetes and they're
unlikely to be managed by the same operator as the system in question.
To build a proper Kubernetes-native management tool for systems with
these sorts of dependencies, the operator will need to interact with
systems outside of its direct purview.
</p>

<p>
The basic "stateful" primitives native to Kubernetes are a useful
first step. The <code>PersistentVolume~/~PersistentVolumeClaim~/~CSI</code>
interfaces are more or less exactly what we're talking about: an
bridge between the Kubernetes world and and the external world. It
turns out that the Kubernetes authors have written the controllers
themselves, so working with these abstractions is somewhat abstracted
from what one might call and operator. But under the hood, it's a
similar idea - a Kubernetes-native, resource-based interface to the
lifecycle of an external stateful service.
</p>

<p>
But what about other resources? What if we have to write the system
ourselves, controller and all? Let's take as a concrete example an
object storage bucket such as Amazon S3 or IBM's Cloud Object Storage.
</p>
</div>
</body>
</html>
